# サポート報告書WEBシステム ストアドプロシージャ詳細設計書

**作成日**: 2025-11-25  
**更新日**: 2025-12-04  
**バージョン**: 1.1  
**Phase**: 04

---

## 1. 概要

本資料は、サポート報告書WEBシステムで使用するストアドプロシージャの詳細仕様を定義したものです。
既存のストアドプロシージャの仕様確認と、WEB版で新規に必要となるストアドプロシージャの設計を含みます。

---

## 2. ストアドプロシージャ分類

| 分類 | 説明 | SP数 |
|------|------|------|
| システム系 | SEQNO採番、バックアップ等 | 3 |
| 作業報告系 | 登録・更新・削除・検索 | 5 |
| 商品マスタ系 | CRUD操作 | 3 |
| 対応区分マスタ系 | CRUD操作 | 3 |
| 対応内容項目マスタ系 | CRUD操作 | 3 |
| 定型文マスタ系 | CRUD操作 | 3 |
| WEB版新規追加 | 検索・一覧・集計 | 5 |

---

## 3. 既存ストアドプロシージャ詳細

### 3.1 システム系

#### 3.1.1 COUNTUP_SYS_SEQNO

**用途**: D_作業報告のSEQNOを採番

**パラメータ**: なし

**戻り値**: なし（テーブルを直接更新）

**処理ロジック**:
```sql
UPDATE SYS_SEQNO SET SEQNO = SEQNO + COUNTVAL
```

**呼び出し例（PHP）**:
```php
$stmt = $pdo_conn->prepare("EXEC dbo.COUNTUP_SYS_SEQNO");
$stmt->execute();

$stmt2 = $pdo_conn->query("SELECT SEQNO FROM SYS_SEQNO");
$new_seqno = $stmt2->fetchColumn();
```

**WEB版対応**: 継続使用（変更なし）

---

#### 3.1.2 CRE_DB_BACKUP

**用途**: データベースの完全バックアップを作成

**パラメータ**:

| パラメータ | 方向 | 型 | 説明 |
|-----------|------|-----|------|
| @BackupPath | IN | NVARCHAR(500) | バックアップファイルパス |

**処理ロジック**:
```sql
DECLARE @SQL NVARCHAR(MAX)
SET @SQL = 'BACKUP DATABASE SUPPORTDB TO DISK = ''' + @BackupPath + ''''
EXEC sp_executesql @SQL
```

**WEB版対応**: 使用しない（サーバー側のバッチ処理で実行）

---

### 3.2 作業報告系

#### 3.2.1 UPD_D_作業報告

**用途**: 作業報告の新規登録・更新（UPSERT）

**パラメータ**:

| パラメータ | 方向 | 型 | NULL可 | 説明 |
|-----------|------|-----|--------|------|
| @SEQNO | IN | BIGINT | YES | シーケンス番号（NULL時は新規） |
| @対応開始日時 | IN | DATETIME | NO | 対応開始日時 |
| @対応終了日時 | IN | DATETIME | YES | 対応終了日時 |
| @顧客コード | IN | BIGINT | YES | 顧客コード |
| @顧客担当者名 | IN | NVARCHAR(255) | YES | 顧客担当者名 |
| @部門コード | IN | BIGINT | YES | 部門コード |
| @商品コード1 | IN | BIGINT | YES | 商品コード1 |
| @商品コード2 | IN | BIGINT | YES | 商品コード2 |
| @商品コード3 | IN | BIGINT | YES | 商品コード3 |
| @作業担当コード | IN | BIGINT | YES | 作業担当コード |
| @対応区分コード | IN | BIGINT | YES | 対応区分コード |
| @結果コード | IN | BIGINT | YES | 結果コード |
| @引継担当コード | IN | BIGINT | YES | 引継担当コード |
| @報告内容 | IN | NVARCHAR(MAX) | YES | 報告内容 |
| @お客様サイン | IN | NVARCHAR(255) | YES | お客様サイン |
| @確認日付 | IN | DATETIME | YES | 確認日付 |
| @作成日時 | IN | DATETIME | YES | 作成日時 |
| @同期日時 | IN | DATETIME | YES | 同期日時 |
| @更新日時 | IN | DATETIME | YES | 更新日時 |
| @削除日時 | IN | DATETIME | YES | 削除日時 |
| @入力マシン | IN | NVARCHAR(255) | NO | 入力マシン |
| @更新マシン | IN | NVARCHAR(255) | YES | 更新マシン |
| @ネットワークFLG | IN | BIT | YES | ネットワークフラグ |
| @対応内容項目名1〜20 | IN | NVARCHAR(255) | YES | 対応内容項目名 |
| @対応内容フラグ1〜20 | IN | BIGINT | YES | 対応内容フラグ |
| @OUTPUTSEQNO | OUT | INT | - | 登録されたSEQNO |

**処理ロジック**:
```sql
-- 存在チェック
IF EXISTS (SELECT 1 FROM D_作業報告 WHERE SEQNO = @SEQNO AND 入力マシン = @入力マシン)
BEGIN
    -- UPDATE処理
    UPDATE D_作業報告 SET
        対応開始日時 = @対応開始日時,
        -- 省略
        更新日時 = GETDATE()
    WHERE SEQNO = @SEQNO AND 入力マシン = @入力マシン;
    
    SET @OUTPUTSEQNO = @SEQNO;
END
ELSE
BEGIN
    -- 新規SEQNO採番
    EXEC dbo.COUNTUP_SYS_SEQNO;
    SELECT @SEQNO = SEQNO FROM SYS_SEQNO;
    
    -- INSERT処理
    INSERT INTO D_作業報告 (SEQNO, 入力マシン, ...)
    VALUES (@SEQNO, @入力マシン, ...);
    
    SET @OUTPUTSEQNO = @SEQNO;
END
```

**呼び出し例（PHP）**:
```php
$sql = "EXEC dbo.UPD_D_作業報告 
    @SEQNO = ?, @対応開始日時 = ?, @対応終了日時 = ?,
    -- 省略
    @OUTPUTSEQNO = ? OUTPUT";

$stmt = $pdo_conn->prepare($sql);
$stmt->execute(array(
    $seqno, $taiou_start, $taiou_end,
    // 省略
));

// OUTPUT取得
$stmt->nextRowset();
$result = $stmt->fetch();
$new_seqno = $result['OUTPUTSEQNO'];
```

**WEB版対応**: 
- 入力マシンを「WEB」固定に変更
- 同期日時は常にNULL
- ネットワークFLGは常に1

---

#### 3.2.2 DEL_D_作業報告

**用途**: 作業報告の論理削除

**パラメータ**:

| パラメータ | 方向 | 型 | 説明 |
|-----------|------|-----|------|
| @SEQNO | IN | BIGINT | 削除対象SEQNO |
| @削除日時 | IN | DATETIME | 削除日時 |
| @更新マシン | IN | NVARCHAR(255) | 更新マシン名 |
| @OUTPUTSEQNO | OUT | INT | 削除されたSEQNO |

**処理ロジック**:
```sql
UPDATE D_作業報告
SET 削除日時 = @削除日時,
    更新マシン = @更新マシン
WHERE SEQNO = @SEQNO;

SET @OUTPUTSEQNO = @SEQNO;
```

**WEB版対応**: 継続使用（更新マシンを「WEB」固定）

---

#### 3.2.3 SEL_D_作業報告_同期

**用途**: Access側との同期用データ取得

**WEB版対応**: **使用しない**（Access特有の処理）

---

#### 3.2.4 GET_D_作業報告_最終更新

**用途**: 担当者の最終更新日時を取得

**パラメータ**:

| パラメータ | 方向 | 型 | 説明 |
|-----------|------|-----|------|
| @作業担当者コード | IN | INT | 担当者コード |
| @MaxDate | OUT | DATETIME | 最終更新日時 |

**WEB版対応**: 継続使用可能（ダッシュボード用）

---

### 3.3 商品マスタ系

#### 3.3.1 UPD_M_商品

**用途**: 商品マスタの登録・更新（UPSERT）

**パラメータ**:

| パラメータ | 方向 | 型 | 説明 |
|-----------|------|-----|------|
| @商品コード | IN | INT | 商品コード |
| @部門コード | IN | INT | 部門コード |
| @商品名 | IN | NVARCHAR(50) | 商品名 |
| @使用区分 | IN | INT | 使用区分（0/1） |
| @更新日時 | IN | DATETIME | 更新日時 |
| @入力マシン | IN | NVARCHAR(20) | 入力マシン |
| @SQL処理 | OUT | NVARCHAR(10) | 'UPD' or 'INS' |
| @SQL処理件数 | OUT | INT | 処理件数 |

**処理ロジック**:
```sql
IF EXISTS (SELECT 1 FROM M_商品 WHERE 商品コード = @商品コード)
BEGIN
    UPDATE M_商品 SET
        部門コード = @部門コード,
        商品名 = @商品名,
        使用区分 = @使用区分,
        更新日時 = @更新日時,
        入力マシン = @入力マシン
    WHERE 商品コード = @商品コード;
    
    SET @SQL処理 = 'UPD';
    SET @SQL処理件数 = @@ROWCOUNT;
END
ELSE
BEGIN
    INSERT INTO M_商品 (商品コード, 部門コード, 商品名, 使用区分, 更新日時, 入力マシン)
    VALUES (@商品コード, @部門コード, @商品名, @使用区分, @更新日時, @入力マシン);
    
    SET @SQL処理 = 'INS';
    SET @SQL処理件数 = @@ROWCOUNT;
END
```

**呼び出し例（PHP）**:
```php
$sql = "EXEC dbo.UPD_M_商品 
    @商品コード = ?, @部門コード = ?, @商品名 = ?,
    @使用区分 = ?, @更新日時 = ?, @入力マシン = ?,
    @SQL処理 = ? OUTPUT, @SQL処理件数 = ? OUTPUT";

$stmt = $pdo_conn->prepare($sql);
$stmt->execute(array($code, $bumon, $name, $use, date('Y-m-d H:i:s'), 'WEB'));
```

**WEB版対応**: 継続使用（入力マシンを「WEB」固定）

---

#### 3.3.2 SEL_M_商品

**用途**: 商品マスタの範囲検索

**パラメータ**:

| パラメータ | 方向 | 型 | 説明 |
|-----------|------|-----|------|
| @商品コード開始 | IN | INT | 開始コード |
| @商品コード終了 | IN | INT | 終了コード |

**処理ロジック**:
```sql
SELECT * FROM M_商品
WHERE 商品コード BETWEEN @商品コード開始 AND @商品コード終了
ORDER BY 商品コード
```

**WEB版対応**: 継続使用（全件取得は0〜999999999を指定）

---

#### 3.3.3 DEL_商品

**用途**: 商品マスタの削除（履歴保存後に物理削除）

**パラメータ**:

| パラメータ | 方向 | 型 | 説明 |
|-----------|------|-----|------|
| @商品コード | IN | INT | 削除する商品コード |
| @SQL処理件数 | OUT | INT | 削除件数 |

**処理ロジック**:
```sql
-- 削除履歴へコピー
INSERT INTO DELDATA_商品
SELECT *, GETDATE() AS 削除日時
FROM M_商品
WHERE 商品コード = @商品コード;

-- マスタから削除
DELETE FROM M_商品 WHERE 商品コード = @商品コード;

SET @SQL処理件数 = @@ROWCOUNT;
```

**WEB版対応**: 継続使用

---

### 3.4 対応区分マスタ系

#### 3.4.1 UPD_M_対応区分

**パラメータ**:

| パラメータ | 方向 | 型 | 説明 |
|-----------|------|-----|------|
| @対応区分コード | IN | INT | 区分コード |
| @対応区分名 | IN | NVARCHAR(50) | 区分名 |
| @更新日時 | IN | DATETIME | 更新日時 |
| @入力マシン | IN | NVARCHAR(20) | 入力マシン |
| @SQL処理 | OUT | NVARCHAR(10) | 'UPD' or 'INS' |
| @SQL処理件数 | OUT | INT | 処理件数 |

**WEB版対応**: 継続使用

---

#### 3.4.2 SEL_M_対応区分

**パラメータ**:

| パラメータ | 方向 | 型 | 説明 |
|-----------|------|-----|------|
| @対応区分コード開始 | IN | INT | 開始コード |
| @対応区分コード終了 | IN | INT | 終了コード |

**WEB版対応**: 継続使用

---

#### 3.4.3 DEL_対応区分

**パラメータ**:

| パラメータ | 方向 | 型 | 説明 |
|-----------|------|-----|------|
| @対応区分コード | IN | INT | 削除するコード |
| @SQL処理件数 | OUT | INT | 削除件数 |

**WEB版対応**: 継続使用

---

### 3.5 対応内容項目マスタ系

#### 3.5.1 UPD_M_対応内容項目

**パラメータ**:

| パラメータ | 方向 | 型 | 説明 |
|-----------|------|-----|------|
| @項目コード | IN | INT | 項目コード（1〜20） |
| @項目名 | IN | NVARCHAR(50) | 項目名 |
| @更新日時 | IN | DATETIME | 更新日時 |
| @入力マシン | IN | NVARCHAR(20) | 入力マシン |
| @SQL処理 | OUT | NVARCHAR(10) | 'UPD' or 'INS' |
| @SQL処理件数 | OUT | INT | 処理件数 |

**WEB版対応**: 継続使用

---

#### 3.5.2 SEL_M_対応内容項目

**パラメータ**:

| パラメータ | 方向 | 型 | 説明 |
|-----------|------|-----|------|
| @項目コード開始 | IN | INT | 開始コード |
| @項目コード終了 | IN | INT | 終了コード |

**WEB版対応**: 継続使用

---

#### 3.5.3 DEL_対応内容項目

**パラメータ**:

| パラメータ | 方向 | 型 | 説明 |
|-----------|------|-----|------|
| @項目コード | IN | INT | 削除するコード |
| @SQL処理件数 | OUT | INT | 削除件数 |

**WEB版対応**: 継続使用

---

### 3.6 定型文マスタ系

#### 3.6.1 UPD_M_定型文

**パラメータ**:

| パラメータ | 方向 | 型 | 説明 |
|-----------|------|-----|------|
| @部門コード | IN | INT | 部門コード |
| @定型文コード | IN | INT | 定型文コード |
| @定型文 | IN | NVARCHAR(50) | 定型文内容 |
| @作成日時 | IN | DATETIME | 作成日時 |
| @作成者コード | IN | INT | 作成者コード |
| @更新日時 | IN | DATETIME | 更新日時 |
| @更新者コード | IN | INT | 更新者コード |
| @SQL処理 | OUT | NVARCHAR(10) | 'UPD' or 'INS' |
| @SQL処理件数 | OUT | INT | 処理件数 |

**WEB版対応**: 継続使用

---

#### 3.6.2 SEL_M_定型文

**パラメータ**:

| パラメータ | 方向 | 型 | 説明 |
|-----------|------|-----|------|
| @部門コード開始 | IN | INT | 部門コード開始 |
| @部門コード終了 | IN | INT | 部門コード終了 |
| @定型文コード開始 | IN | INT | 定型文コード開始 |
| @定型文コード終了 | IN | INT | 定型文コード終了 |

**WEB版対応**: 継続使用

---

#### 3.6.3 DEL_定型文

**パラメータ**:

| パラメータ | 方向 | 型 | 説明 |
|-----------|------|-----|------|
| @部門コード | IN | INT | 部門コード |
| @定型文コード | IN | INT | 定型文コード |
| @SQL処理件数 | OUT | INT | 削除件数 |

**WEB版対応**: 継続使用

---

## 4. WEB版新規作成ストアドプロシージャ

### 4.1 SEL_D_作業報告_検索

**用途**: 作業報告の複合条件検索（ページング対応）

**パラメータ**:

| パラメータ | 方向 | 型 | NULL可 | デフォルト | 説明 |
|-----------|------|-----|--------|-----------|------|
| @対応開始日FROM | IN | DATETIME | YES | NULL | 対応日開始 |
| @対応開始日TO | IN | DATETIME | YES | NULL | 対応日終了 |
| @顧客コード | IN | BIGINT | YES | NULL | 顧客コード |
| @顧客名 | IN | NVARCHAR(255) | YES | NULL | 顧客名（部分一致） |
| @部門コード | IN | BIGINT | YES | NULL | 部門コード |
| @商品コード | IN | BIGINT | YES | NULL | 商品コード（1-3のいずれか） |
| @作業担当コード | IN | BIGINT | YES | NULL | 作業担当コード |
| @対応区分コード | IN | BIGINT | YES | NULL | 対応区分コード |
| @キーワード | IN | NVARCHAR(255) | YES | NULL | 報告内容キーワード |
| @ページ番号 | IN | INT | NO | 1 | ページ番号 |
| @ページサイズ | IN | INT | NO | 50 | 1ページの件数 |
| @ソートカラム | IN | NVARCHAR(50) | NO | '対応開始日時' | ソート列 |
| @ソート順 | IN | NVARCHAR(4) | NO | 'DESC' | ASC or DESC |

**戻り値**: 
- ResultSet1: 検索結果（ページング後）
- ResultSet2: 総件数

**処理ロジック**:
```sql
CREATE PROCEDURE [dbo].[SEL_D_作業報告_検索]
    @対応開始日FROM DATETIME = NULL,
    @対応開始日TO DATETIME = NULL,
    @顧客コード BIGINT = NULL,
    @顧客名 NVARCHAR(255) = NULL,
    @部門コード BIGINT = NULL,
    @商品コード BIGINT = NULL,
    @作業担当コード BIGINT = NULL,
    @対応区分コード BIGINT = NULL,
    @キーワード NVARCHAR(255) = NULL,
    @ページ番号 INT = 1,
    @ページサイズ INT = 50,
    @ソートカラム NVARCHAR(50) = N'対応開始日時',
    @ソート順 NVARCHAR(4) = 'DESC'
AS
BEGIN
    SET NOCOUNT ON;
    
    DECLARE @Offset INT = (@ページ番号 - 1) * @ページサイズ;
    DECLARE @SQL NVARCHAR(MAX);
    DECLARE @CountSQL NVARCHAR(MAX);
    DECLARE @WhereClause NVARCHAR(MAX) = N' WHERE d.削除日時 IS NULL ';
    
    -- 動的WHERE句の構築
    IF @対応開始日FROM IS NOT NULL
        SET @WhereClause = @WhereClause + N' AND d.対応開始日時 >= @p対応開始日FROM ';
    
    IF @対応開始日TO IS NOT NULL
        SET @WhereClause = @WhereClause + N' AND d.対応開始日時 < DATEADD(DAY, 1, @p対応開始日TO) ';
    
    IF @顧客コード IS NOT NULL
        SET @WhereClause = @WhereClause + N' AND d.顧客コード = @p顧客コード ';
    
    IF @顧客名 IS NOT NULL AND @顧客名 <> ''
        SET @WhereClause = @WhereClause + N' AND k.顧客名 LIKE ''%'' + @p顧客名 + ''%'' ';
    
    IF @部門コード IS NOT NULL
        SET @WhereClause = @WhereClause + N' AND d.部門コード = @p部門コード ';
    
    IF @商品コード IS NOT NULL
        SET @WhereClause = @WhereClause + N' AND (d.商品コード1 = @p商品コード OR d.商品コード2 = @p商品コード OR d.商品コード3 = @p商品コード) ';
    
    IF @作業担当コード IS NOT NULL
        SET @WhereClause = @WhereClause + N' AND d.作業担当コード = @p作業担当コード ';
    
    IF @対応区分コード IS NOT NULL
        SET @WhereClause = @WhereClause + N' AND d.対応区分コード = @p対応区分コード ';
    
    IF @キーワード IS NOT NULL AND @キーワード <> ''
        SET @WhereClause = @WhereClause + N' AND d.報告内容 LIKE ''%'' + @pキーワード + ''%'' ';
    
    -- 検索結果取得
    SET @SQL = N'
        SELECT 
            d.SEQNO,
            d.対応開始日時,
            d.対応終了日時,
            d.顧客コード,
            k.顧客名,
            d.顧客担当者名,
            d.部門コード,
            b.部門名,
            d.商品コード1,
            s1.商品名 AS 商品名1,
            d.商品コード2,
            s2.商品名 AS 商品名2,
            d.商品コード3,
            s3.商品名 AS 商品名3,
            d.作業担当コード,
            t.担当者名 AS 作業担当名,
            d.対応区分コード,
            ku.対応区分名,
            d.引継担当コード,
            ht.担当者名 AS 引継担当名,
            d.報告内容,
            d.対応内容フラグ1, d.対応内容フラグ2, d.対応内容フラグ3, d.対応内容フラグ4, d.対応内容フラグ5,
            d.対応内容フラグ6, d.対応内容フラグ7, d.対応内容フラグ8, d.対応内容フラグ9, d.対応内容フラグ10,
            d.対応内容フラグ11, d.対応内容フラグ12, d.対応内容フラグ13, d.対応内容フラグ14, d.対応内容フラグ15,
            d.対応内容フラグ16, d.対応内容フラグ17, d.対応内容フラグ18, d.対応内容フラグ19, d.対応内容フラグ20,
            d.更新日時
        FROM D_作業報告 d
        LEFT JOIN SQL_顧客 k ON d.顧客コード = k.顧客コード
        LEFT JOIN SQL_部門 b ON d.部門コード = b.部門コード
        LEFT JOIN M_商品 s1 ON d.商品コード1 = s1.商品コード
        LEFT JOIN M_商品 s2 ON d.商品コード2 = s2.商品コード
        LEFT JOIN M_商品 s3 ON d.商品コード3 = s3.商品コード
        LEFT JOIN SQL_作業担当 t ON d.作業担当コード = t.担当者コード
        LEFT JOIN M_対応区分 ku ON d.対応区分コード = ku.対応区分コード
        LEFT JOIN SQL_作業担当 ht ON d.引継担当コード = ht.担当者コード
    ' + @WhereClause + N'
        ORDER BY ' + QUOTENAME(@ソートカラム) + N' ' + @ソート順 + N'
        OFFSET @pOffset ROWS FETCH NEXT @pPageSize ROWS ONLY;
    ';
    
    -- 総件数取得
    SET @CountSQL = N'
        SELECT COUNT(*) AS TotalCount
        FROM D_作業報告 d
        LEFT JOIN SQL_顧客 k ON d.顧客コード = k.顧客コード
    ' + @WhereClause + N';
    ';
    
    -- パラメータ定義
    DECLARE @ParamDef NVARCHAR(MAX) = N'
        @p対応開始日FROM DATETIME,
        @p対応開始日TO DATETIME,
        @p顧客コード BIGINT,
        @p顧客名 NVARCHAR(255),
        @p部門コード BIGINT,
        @p商品コード BIGINT,
        @p作業担当コード BIGINT,
        @p対応区分コード BIGINT,
        @pキーワード NVARCHAR(255),
        @pOffset INT,
        @pPageSize INT
    ';
    
    -- 検索結果実行
    EXEC sp_executesql @SQL, @ParamDef,
        @p対応開始日FROM = @対応開始日FROM,
        @p対応開始日TO = @対応開始日TO,
        @p顧客コード = @顧客コード,
        @p顧客名 = @顧客名,
        @p部門コード = @部門コード,
        @p商品コード = @商品コード,
        @p作業担当コード = @作業担当コード,
        @p対応区分コード = @対応区分コード,
        @pキーワード = @キーワード,
        @pOffset = @Offset,
        @pPageSize = @ページサイズ;
    
    -- 総件数実行
    EXEC sp_executesql @CountSQL, @ParamDef,
        @p対応開始日FROM = @対応開始日FROM,
        @p対応開始日TO = @対応開始日TO,
        @p顧客コード = @顧客コード,
        @p顧客名 = @顧客名,
        @p部門コード = @部門コード,
        @p商品コード = @商品コード,
        @p作業担当コード = @作業担当コード,
        @p対応区分コード = @対応区分コード,
        @pキーワード = @キーワード,
        @pOffset = @Offset,
        @pPageSize = @ページサイズ;
END
GO
```

---

### 4.2 SEL_D_作業報告_単一

**用途**: 単一の作業報告を取得

**パラメータ**:

| パラメータ | 方向 | 型 | 説明 |
|-----------|------|-----|------|
| @SEQNO | IN | BIGINT | シーケンス番号 |

**処理ロジック**:
```sql
CREATE PROCEDURE [dbo].[SEL_D_作業報告_単一]
    @SEQNO BIGINT
AS
BEGIN
    SET NOCOUNT ON;
    
    SELECT 
        d.*,
        k.顧客名,
        b.部門名,
        s1.商品名 AS 商品名1,
        s2.商品名 AS 商品名2,
        s3.商品名 AS 商品名3,
        t.担当者名 AS 作業担当名,
        ku.対応区分名,
        ht.担当者名 AS 引継担当名
    FROM D_作業報告 d
    LEFT JOIN SQL_顧客 k ON d.顧客コード = k.顧客コード
    LEFT JOIN SQL_部門 b ON d.部門コード = b.部門コード
    LEFT JOIN M_商品 s1 ON d.商品コード1 = s1.商品コード
    LEFT JOIN M_商品 s2 ON d.商品コード2 = s2.商品コード
    LEFT JOIN M_商品 s3 ON d.商品コード3 = s3.商品コード
    LEFT JOIN SQL_作業担当 t ON d.作業担当コード = t.担当者コード
    LEFT JOIN M_対応区分 ku ON d.対応区分コード = ku.対応区分コード
    LEFT JOIN SQL_作業担当 ht ON d.引継担当コード = ht.担当者コード
    WHERE d.SEQNO = @SEQNO
      AND d.削除日時 IS NULL;
END
GO
```

---

### 4.3 SEL_M_商品_コンボ

**用途**: コンボボックス用に使用中の商品を取得

**パラメータ**:

| パラメータ | 方向 | 型 | NULL可 | 説明 |
|-----------|------|-----|--------|------|
| @部門コード | IN | BIGINT | YES | 部門コード（NULLで全部門） |

**処理ロジック**:
```sql
CREATE PROCEDURE [dbo].[SEL_M_商品_コンボ]
    @部門コード BIGINT = NULL
AS
BEGIN
    SET NOCOUNT ON;
    
    SELECT 商品コード, 商品名
    FROM M_商品
    WHERE 使用区分 = 1
      AND (@部門コード IS NULL OR 部門コード = @部門コード)
    ORDER BY 商品コード;
END
GO
```

---

### 4.4 SEL_M_定型文_部門

**用途**: 部門別の定型文リストを取得

**パラメータ**:

| パラメータ | 方向 | 型 | 説明 |
|-----------|------|-----|------|
| @部門コード | IN | BIGINT | 部門コード |

**処理ロジック**:
```sql
CREATE PROCEDURE [dbo].[SEL_M_定型文_部門]
    @部門コード BIGINT
AS
BEGIN
    SET NOCOUNT ON;
    
    SELECT 定型文コード, 定型文
    FROM M_定型文
    WHERE 部門コード = @部門コード
    ORDER BY 定型文コード;
END
GO
```

---

### 4.5 CHK_ログイン

**用途**: ログイン認証

> **変更 (2025-12-04)**: SQL_作業担当テーブルがSUPPORTDB内のローカルテーブルに変更。
> 権限レベルカラムが存在しないため、戻り値から削除。

**パラメータ**:

| パラメータ | 方向 | 型 | 説明 |
|-----------|------|-----|------|
| @担当者コード | IN | BIGINT | 担当者コード |
| @パスワード | IN | NVARCHAR(255) | パスワード |

**戻り値**: 認証成功時は担当者情報、失敗時は空

**処理ロジック**:
```sql
CREATE PROCEDURE [dbo].[CHK_ログイン]
    @担当者コード BIGINT,
    @パスワード NVARCHAR(255)
AS
BEGIN
    SET NOCOUNT ON;
    
    -- SQL_作業担当はSUPPORTDB内のローカルテーブルを参照
    SELECT 
        担当者コード,
        担当者名,
        部門コード
    FROM SQL_作業担当
    WHERE 担当者コード = @担当者コード
      AND パスワード = @パスワード;
END
GO
```

**備考**:
- 権限レベルカラムはテーブルに存在しないため、WEB版では別途管理が必要
- 現行は全ユーザーを同等権限として扱う

---

## 5. PHP呼び出しパターン

### 5.1 単純な取得

```php
// マスタ全件取得
$stmt = $pdo_conn->prepare("EXEC dbo.SEL_M_対応区分 @対応区分コード開始 = 0, @対応区分コード終了 = 999999999");
$stmt->execute();
$kubun_list = $stmt->fetchAll(PDO::FETCH_ASSOC);
```

### 5.2 パラメータ付き取得

```php
// 条件検索
$stmt = $pdo_conn->prepare("EXEC dbo.SEL_D_作業報告_検索 
    @対応開始日FROM = ?, @対応開始日TO = ?,
    @作業担当コード = ?, @ページ番号 = ?, @ページサイズ = ?");
$stmt->execute(array($date_from, $date_to, $tantou_code, $page, 50));
$results = $stmt->fetchAll(PDO::FETCH_ASSOC);

// 2番目の結果セット（総件数）を取得
$stmt->nextRowset();
$count_row = $stmt->fetch(PDO::FETCH_ASSOC);
$total_count = $count_row['TotalCount'];
```

### 5.3 OUTPUT付き実行

```php
// 登録・更新（OUTPUTパラメータ付き）
$sql = "
DECLARE @output_seqno INT;
EXEC dbo.UPD_D_作業報告 
    @SEQNO = ?, @対応開始日時 = ?, /* 省略 */
    @OUTPUTSEQNO = @output_seqno OUTPUT;
SELECT @output_seqno AS OUTPUTSEQNO;
";
$stmt = $pdo_conn->prepare($sql);
$stmt->execute(array($seqno, $taiou_start, /* 省略 */));
$result = $stmt->fetch(PDO::FETCH_ASSOC);
$new_seqno = $result['OUTPUTSEQNO'];
```

---

## 6. エラーハンドリング

### 6.1 SP内のエラーハンドリング（新規追加SP用）

```sql
CREATE PROCEDURE [dbo].[SP_サンプル]
AS
BEGIN
    SET NOCOUNT ON;
    
    BEGIN TRY
        BEGIN TRANSACTION;
        
        -- 処理本体
        
        COMMIT TRANSACTION;
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0
            ROLLBACK TRANSACTION;
        
        -- エラー情報を返す
        SELECT 
            -1 AS ResultCode,
            ERROR_NUMBER() AS ErrorNumber,
            ERROR_MESSAGE() AS ErrorMessage,
            ERROR_LINE() AS ErrorLine;
    END CATCH
END
GO
```

### 6.2 PHP側のエラーハンドリング

```php
try {
    $pdo_conn->beginTransaction();
    
    // SP実行
    $stmt = $pdo_conn->prepare("EXEC dbo.UPD_D_作業報告 ...");
    $stmt->execute($params);
    
    $pdo_conn->commit();
    
} catch (PDOException $e) {
    $pdo_conn->rollBack();
    
    $err_msg[] = 'データベースエラー: ' . $e->getMessage();
    error_log('SP実行エラー: ' . $e->getMessage());
}
```

---

## 7. パフォーマンス考慮事項

### 7.1 インデックス活用

- WHERE句で使用するカラムにはインデックスを設定
- LIKE検索は前方一致のみインデックス有効

### 7.2 ページング最適化

- OFFSET-FETCH使用（SQL Server 2012以降）
- 総件数は別クエリで取得

### 7.3 N+1問題回避

- JOINで一括取得
- 必要なカラムのみSELECT

---

**作成者**: Claude AI  
**レビュー**: Phase 04完了時  
**改訂履歴**:
- v1.0 (2025-11-25): 初版作成
- v1.1 (2025-12-04): CHK_ログインSPの参照先をローカルテーブルに変更、権限レベルカラムを削除
